Python Boolean and Conditional Programming: if.. else
June 8, 2022
Besides numbers and strings, Python has several other types of data. One of them is the Boolean data type. Booleans are extremely simple: they are either true or false. Booleans, in combination with Boolean operators, make it possible to create conditional programs: programs that decide to do different things, based on certain conditions.

The Boolean data type was named after George Boole, the man that defined an algebraic system of logic in the mid 19th century.

What is a Boolean?
Let’s start with a definition:

Boolean
A boolean is the simplest data type; it’s either True or False.
In computer science, booleans are used a lot. This has to do with how computers work internally. Many operations inside a computer come down to a simple “true or false.” It’s important to note, that in Python a Boolean value starts with an upper-case letter: True or False. This is in contrast to most other programming languages, where lower-case is the norm.

In Python, we use booleans in combination with conditional statements to control the flow of a program:

>>> door_is_locked = True
>>> if door_is_locked:
...     print("Mum, open the door!")
...
Mum, open the door!
>>>_
An if can be followed by an optional else block. This block is executed only when the expression evaluates to False. This way, you can run code for both options. Let’s try this:

>>> door_is_locked = False
>>> if door_is_locked:
...     print("Mum, open the door!")
... else:
...     print("Let's go inside")
...
Let's go inside
>>>_
Thanks to our else-block, we can now print an alternative text if door_is_locked is False. As an exercise, try to modify the interactive code example above to get the same result.
An if can be followed by an optional else block. This block is executed only when the expression evaluates to False. This way, you can run code for both options. Let’s try this:

>>> door_is_locked = False
>>> if door_is_locked:
...     print("Mum, open the door!")
... else:
...     print("Let's go inside")
...
Let's go inside
>>>_
Thanks to our else-block, we can now print an alternative text if door_is_locked is False. As an exercise, try to modify the interactive code example above to get the same result.
Python operators
The ability to use conditions is what makes computers tick; they make your software smart and allow it to change its behavior based on external input. We’ve used True directly so far, but more expressions evaluate to either True or False. These expressions often include a so-called operator.

There are multiple types of operators, and for now, we’ll only look at these:

Comparison operators: they compare two values to each other
Logical operators

Comparison operators
Let’s look at comparison operators first. You can play around with them in the REPL:

>>> 2 > 1
True
>>> 2 < 1
False
>>> 2 < 3 < 4 < 5 < 6
True
>>> 2 < 3 > 2
True
>>> 3 <= 3
True
>>> 3 >= 2
True
>>> 2 == 2
True
>>> 4 != 5
True
>>> 'a' == 'a'
True
>>> 'a' > 'b'
False
As can be seen in the examples, these operators work on strings too. Strings are compared in the order of the alphabet, with these added rules:

Uppercase letters are ‘smaller’ than lowercase letters, e.g.: ‘M’ < ‘m’
Digits are smaller than letters: ‘1’ < ‘a’
You’re probably wondering what the logic is behind these rules. Internally, each character has a number in a table. The position in this table determines the order. It’s as simple as that. See Unicode on Wikipedia to learn more about it if you’re interested.
Logical operators
Next up: logical operators. These operators only work on booleans and are used to implement logic. The following table lists and describes them:

Operator	What is does	Examples
and	True if both statements are true	True and False == False
False and False == False
True and True == True
or	True if one of the statements is true	True or False == True
True or True == True
False or False == False
not	Negates the statement that follows	not True == False
not False == True
Comparing different types in Python
When you try to compare different types, you’ll often get an error. Let’s say you want to compare an integer with a string:

>>> 1 < 'a'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '<' not supported between instances of 'int' and 'str'
>>>
This is how Python tells you it can’t compare integers to strings. But there are types that can mix and match. I would recommend against it because it makes your code hard to understand, but for sake of demonstration, let’s compare a boolean and an int:
True + True = 2
False + False = 0
True == 1
True. 
Python For Loop and While Loop
June 5, 2022
We learned how we can change the flow of our program with the conditional statements if and else. Another way to control the flow is by using a Python for-loop or a Python while-loop. Loops, in essence, allow you to repeat a piece of code.
Python For-loop
There are two ways to create a loop in Python. Let’s first look at Python’s for-loop. A for-loop iterates over the individual elements of the object you feed it. If that sounds difficult, an example will hopefully clarify this:

>>> for letter in 'Hello':
...     print(letter)
... 
H
e
l
l
o
We stumbled upon two concepts here that need an explanation: iterability and objects.

Iterable
An iterable is an object in Python that can return its members one at a time.
As you can see in the example code, a string of text is iterable. Most of Python’s data types are iterable in some way or another. If you want to know all the nitty-gritty details, head over to the page about iterators. If you’re new to programming, I suggest you keep reading here and save iterators for later.

The next thing we need to tackle: objects. This is a big subject, and it has its own chapter in this tutorial: Python classes and objects. You don’t need to learn about it now to understand Python for-loops. It’s enough to know that everything in Python is an object, and objects have a certain type and certain properties. Being iterable is one of those properties.
The general template for a for-loop in Python is:

for <variable> in <iterable>:
    ... do something with variable
On each iteration, an element from iterable is assigned to variable. This variable exists and can be used only inside the loop. Once there is nothing more left, the loop stops and the program continues with the next lines of code.

we create lists with block quotes.
Its contents are objects of whatever type you like, separated by commas, and they don’t need to be of the same type.
We can access the individual elements of a list manually too.
A list can contain all the types we’ve seen so far: numbers, strings, booleans, and even other lists. Indeed, you can create a list of lists if you want! As you can see in the interactive example, we can also access individual elements of a list. Remember that in computer science, we start counting from 0. So mylist[0] gives us the first element, and mylist[1] the second, etcetera.

Here are a couple of things you can try in a REPL or in the interactive code example above:

>>> mylist = [1, 2, 'Hello', ['a', 'b'] ]
>>> mylist[0]
1
>>> mylist[0] + mylist[1]
3
>>> mylist[2]
'Hello'
>>> mylist[3][0]
'a'
Python While-loop
While the for-loop in Python is a bit hard to understand, because of new concepts like iterability and objects, the while loop is actually much simpler! Its template looks like this:

while <expression evaluates to True>:
    do something
You should read this as: “while this expression evaluates to True, keep doing the stuff below”.

Let’s take a look at an actual example:

>>> i = 1
>>> while i <= 4:
...     print(i)
...     i = i + 1
... 
1
2
3
4
We see an expression that follows the while statement: i <= 4. As long as this expression evaluates to True, the block inside of the while-loop executes repeatedly.

What is a function in Python?
Let’s define what a function is, exactly:

Function
A Python function is a named section of a program that performs a specific task and, optionally, returns a value
Functions are the real building blocks of any programming language. We define a Python function with the def keyword. But before we start doing so, let’s first go over the advantages of functions, and let’s look at some built-in functions that you might already know.
Advantages of using functions
Code reuse
A Python function can be defined once and used many times. So it aids in code reuse: you don’t want to write the same code more than once.

Functions are a great way to keep your code short, concise, and readable. By giving a function a well-chosen name, your code will become even more readable because the function name directly explains what will happen. This way, others (or future you) can read your code, and without looking at all of it, understand what it’s doing anyway because of the well-chosen function names.

Other forms of code reuse are explained later on. E.g., you can also group code into modules and packages.

Parameters
Functions accept a parameter, and you’ll see how this works in a moment. The big advantage here, is that you can alter the function’s behavior by changing the parameter.

Return values
A function can return a value. This value is often the result of some calculation or operation. In fact, a Python function can even return multiple values.

Built-in Python functions
Before we start defining functions ourselves, we’ll look at some of Python’s built-in functions. Let’s start with the most well-known built-in function, called print:

>>> print('Hello, readers!')
Hello, readers!
>>> print(15)
15
Print takes an argument and prints it to the screen.

As stated in our definition, functions can optionally return a value. However, print does not return anything. Because it prints something to the screen, it might look like it does, but it doesn’t. We can check this by assigning the result of a print statement to a Python variable:
>>> result = print('Hello')
Hello
>>> print(result)
None
None is a special type of value in Python, basically meaning ‘nothing.’

Another built-in function that does return a value is len(). It returns the length of whatever you feed it:

>>> mylength = len('Hello')
>>> print(mylength)
5
Creating a Python function
Now that we know how to use a function, let’s create a simple one ourselves. To do so, we use Python’s def keyword:

>>> def say_hi():
...     print('Hi!')
...
>>> say_hi()
Hi!
It’s just a few lines, but a lot is going on. Let’s dissect this:

First, we see the keyword def, which is Python’s keyword to define a function.
Next comes our function name, say_hi.
Then we encounter two parentheses, (), which indicate that this function does not accept any parameters (unlike print and len).
We end the line with a colon (:)
And finally, we bump into a feature that sets Python apart from many other programming languages: indentation.
Python function parameters and arguments
We can make this more interesting by allowing an argument to be passed to our function. Again we define a function with def, but we add a variable name between the parentheses:

>>> def say_hi(name):
...     print('Hi', name)
...
>>> say_hi('Erik')
Hi Erik
Our function now accepts a value, which gets assigned to the variable name. We call such variables the parameter, while the actual value we provide (‘Erik’) is called the argument.

Parameters and arguments
A Python function can have parameters. The values we pass through these parameters are called arguments.
As you can see, print() accepts multiple arguments, separated by a comma. This allows us to print both ‘hi’ and the provided name. For our convenience, print() automatically puts a space between the two strings.
Empty return statement
If your function does not return anything, but you still want to return from the function, you can use an empty return statement. Here’s a silly example that uses the startswith() method of a string. This method checks if the string starts with the given string:

def optional_greeter(name):
    if name.startswith('X'):
        # We don't greet people with weird names :p
        return
    
    print('Hi there, ', name)
optional_greeter('Xander')
This is an interesting pattern; I call it returning early. I’d like to return early because the alternative is using blocks of if… else statements:

def optional_greeter(name):
    if name.startswith('X'):
        # We don't greet people with weird names :p
        pass
    else:
        print('Hi there, ', name)
optional_greeter('Xander')
Which one do you feel looks cleaner? I’d say the first because it requires less indented code. And although the difference is small with such a small example, this starts to add up when you have bigger chunks of code.
Variable scope
The variable name only exists inside our function. We say that the variable’s scope name is limited to the function say_hi, meaning it doesn’t exist outside of it.

Scope
The visibility of a variable is called scope. The scope defines which parts of your program can see and use a variable.
If we define a variable at the so-called top level of a program, it is visible in all places.

Let’s demonstrate this:

>>> def say_hi():
...    print("Hi", name)
...    answer = "Hi"
...
>>> name = 'Erik'
>>> say_hi()
Hi Erik
>>> print(answer)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'answer' is not defined
say_hi was able to use the variable name, as expected, because it’s a top-level variable: it is visible everywhere. However, answer, defined inside say_hi, is not known outside of the function and causes a NameError. Python gives us an informative and detailed error: “name ‘answer’ is not defined.”
Default values and named parameters
A compelling Python feature is the ability to provide default values for the parameters:

>>> def welcome(name='learner', location='this tutorial'):
...     print("Hi", name, "welcome to", location)
...
>>> welcome()
Hi learner welcome to this tutorial
>>> welcome(name='John')
Hi John welcome to this tutorial
>>> welcome(location='this epic tutorial')
Hi learner welcome to this epic tutorial
>>> welcome(name='John', location='this epic tutorial')
Hi John welcome to this epic tutorial
